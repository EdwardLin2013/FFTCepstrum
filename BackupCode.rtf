{\rtf1\ansi\ansicpg1252\cocoartf1265\cocoasubrtf210
{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red0\green116\blue0;\red170\green13\blue145;\red92\green38\blue153;
\red28\green0\blue207;\red63\green110\blue116;\red46\green13\blue110;\red196\green26\blue22;}
\paperw11900\paperh16840\margl1440\margr1440\vieww20880\viewh11860\viewkind0
\deftab529
\pard\tx529\pardeftab529\pardirnatural

\f0\fs22 \cf0 \CocoaLigature0     \cf2 /*\
    for (UInt32 i=0; i<_FrameSize; i++)\
    \{\
        printf("Raw Data: inData[%ld]: %f\\n", i, inData[i]);\
    \}\
    */\
\
\cf0     \cf2 /*\
    for (UInt32 i=0; i<_FFTLength; i++)\
        printf(\'93Just After FFT: outFFTData[%ld]: %f\\n", i, outFFTData[i]);\
     */\
\
\cf0     \cf2 /*\
    for (UInt32 i=0; i<_FrameSize; i++)\
        printf("Before take log: _DspVector[%ld]: %f\\n", i, _DspVector[i]);\
    */\
\
/*\
    for (UInt32 i=0; i<_FFTLength; i++)\
    \{\
        printf("After FFT: outCepstrumData[%ld]: %f\\n", i, outCepstrumData[i]);\
    \}\
    */\
\
\cf0         \cf2 //printf("After take log: _DspVector[%ld]: %f\\n", i, _DspVector[i]);\
\
// Fill up the last half of inFFTData, basically is the inverse mirror\cf0 \
    \cf3 for\cf0  (\cf4 UInt32\cf0  i=\cf5 0\cf0 ; i<\cf6 _FFTLength\cf0 -\cf5 1\cf0 ; i++)\
    \{\
        \cf6 _DspVector\cf0 [i+\cf5 1\cf0 ] = inFFTData[i+\cf5 1\cf0 ];\
        \cf6 _DspVector\cf0 [\cf6 _FrameSize\cf0 -\cf5 1\cf0 -i] = inFFTData[i+\cf5 1\cf0 ];\
    \}\
    \cf2 // Match the result of Matlab\cf0 \
    \cf2 //_DspVector[0] = inFFTData[0];\cf0 \
    \cf2 //_DspVector[_FFTLength] = kAdjust0DB;\
\
\
\cf0     \cf2 /*\
    for (UInt32 i=0; i<_FrameSize; i++)\
        printf("After take log: _DspVector[%ld]: %f\\n", i, _DspVector[i]);\
    */\
\
/*\
    for (UInt32 i=0; i<_FFTLength+1; i++)\
        printf("Just After FFT: _DspSplitComplex[%ld]: %f + %f i\\n", i, _DspSplitComplex.realp[i], _DspSplitComplex.imagp[i]);\
    */\cf0 \
    \cf2 //vDSP_vsmul(_DspSplitComplex.realp, 1, &_FFTNormFactor, _DspSplitComplex.realp, 1, _FFTLength);\cf0 \
    \cf2 //vDSP_vsmul(_DspSplitComplex.imagp, 1, &_FFTNormFactor, _DspSplitComplex.imagp, 1, _FFTLength);\
\
\cf0     \cf2 //vDSP_zvmags(&_DspSplitComplex, 1, outFFTData, 1, _FFTLength);\
\
\cf0     \
    \cf2 /*\
    for (UInt32 i=0; i<_FFTLength; i++)\
        printf("After FFT: outFFTData[%ld]: %f\\n", i, outFFTData[i]);\
     */\
\
\cf0     \
    \cf3 for\cf0  (\cf4 UInt32\cf0  i=\cf5 0\cf0 ; i<\cf6 _FFTLength\cf0 ; i++)\
        \cf7 printf\cf0 (\cf8 "After FFT: outFFTDataInDB[%ld]: %f\\n"\cf0 , i, outFFTDataInDB[i]);\
\
\
\
\
    \cf3 for\cf0  (\cf4 UInt32\cf0  i=\cf5 0\cf0 ; i<\cf6 _FrameSize\cf0 ; i++)\
        \cf7 printf\cf0 (\cf8 "inData[%ld]: %f\\n"\cf0 , i, inData[i]);\
    \cf3 for\cf0  (\cf4 UInt32\cf0  i=\cf5 0\cf0 ; i<\cf6 _FFTLength\cf0 ; i++)\
        \cf7 printf\cf0 (\cf8 "Just After FFT: _DspSplitComplex[%ld]: %f + %f i\\n"\cf0 , i, \cf6 _DspSplitComplex\cf0 .\cf4 realp\cf0 [i], \cf6 _DspSplitComplex\cf0 .\cf4 imagp\cf0 [i]);\
\
\
\
\
\
\
}